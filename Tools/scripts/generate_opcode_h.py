# This script generates the opcode.h header file.

import sys
import tokenize
import textwrap


TEMPLATE = """
/* Auto-generated by Tools/scripts/generate_opcode_h.py from Lib/opcode.py */

#ifndef Py_OPCODE_H
#define Py_OPCODE_H

#ifdef __cplusplus
extern "C" {
#endif


<INSTRUCTIONS>


<OPCODE TABLES>

#ifdef __cplusplus
}
#endif
#endif /* !Py_OPCODE_H */

""".lstrip()

UINT32_MASK = (1<<32)-1


def render_opcodes(opcode_module):
    opnames = opcode_module["opname"]
    opcodes = opcode_module["opmap"]
    metaops = {opcode_module[name]: name
               for name in [
                   "HAVE_ARGUMENT",
               ]}
    metaops = dict(sorted(metaops.items()))

    yield "/* Instruction opcodes for compiled code */"
    yield ""

    prev = 0
    blank = False
    for name in opnames:
        if name not in opcodes:
            if name.startswith("<") and name.endswith(">"):
                if name[1:-1].isdigit():
                    continue
            raise NotImplementedError(f"opcode {name!r} did not get added to opmap")
        op = opcodes[name]

        for metaop in list(metaops):
            if metaop <= op:
                metaname = metaops.pop(metaop)
                if not blank:
                    yield ""
                yield "/* This is a meta opcode, not one the compiler actually generates. */"
                yield f"#define {metaname:23} {metaop:>3}"
                yield ""
                blank = True
                prev = metaop

        if op != prev + 1:
            if not blank:
               yield ""
        prev = op
        yield f"#define {name:23} {op:>3}"
        blank = False

    yield from textwrap.dedent("""
        #define HAS_ARG(op) ((op) >= HAVE_ARGUMENT)

        /* Reserve some bytecodes for internal use in the compiler.
         * The value of 240 is arbitrary. */
        #define IS_ARTIFICIAL(op) ((op) > 240)
    """).splitlines()


def render_int_array_from_ops(name, ops):
    bits = 0
    for op in ops:
        bits |= 1<<op
    yield f"static uint32_t {name}[8] = {{"
    for i in range(8):
        yield f"    {bits & UINT32_MASK}U,"
        bits >>= 32
    assert bits == 0
    yield f"}};"


def render_opcode_h(opcode):
    tables = {
        "_PyOpcode_RelativeJump": opcode['hasjrel'],
        "_PyOpcode_Jump": opcode['hasjrel'] + opcode['hasjabs'],
    }
    for line in TEMPLATE.splitlines():
        if line == "<INSTRUCTIONS>":
            yield from render_opcodes(opcode)
        elif line == "<OPCODE TABLES>":
            yield "#ifdef NEED_OPCODE_JUMP_TABLES"
            for table, ops in tables.items():
                yield from render_int_array_from_ops(table, ops)
            yield "#endif /* OPCODE_TABLES */"
        else:
            yield line


def main(opcode_py, outfile='Include/opcode.h'):
    opcode = {}
    with tokenize.open(opcode_py) as fp:
        code = fp.read()
    exec(code, opcode)

    text = "\n".join(render_opcode_h(opcode))
    with open(outfile, 'w') as fobj:
        fobj.write(text)

    print("%s regenerated from %s" % (outfile, opcode_py))


if __name__ == '__main__':
    main(sys.argv[1], sys.argv[2])
